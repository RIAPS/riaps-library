//
// Auto-generated by edu.vanderbilt.riaps.generator.ComponenetGenerator.xtend
//
#include <base/ComputationalComponentBase.h>
#include <componentmodel/r_pyconfigconverter.h>

namespace riapsmodbuscreqrepuart {
   namespace components {
      
      ComputationalComponentBase::ComputationalComponentBase(const py::object *parent_actor,
                                                             const py::dict actor_spec,
                                                             const py::dict type_spec,
                                                             const std::string &name,
                                                             const std::string &type_name,
                                                             const py::dict args,
                                                             const std::string &application_name,
                                                             const std::string &actor_name) : ComponentBase(application_name, actor_name) {
          auto conf = PyConfigConverter::convert(type_spec, actor_spec);
          conf.component_name = name;
          conf.component_type = type_name;
          conf.isDevice=false;
          set_config(conf);
      }
      
      void ComputationalComponentBase::DispatchMessage(capnp::FlatArrayMessageReader* capnpreader, riaps::ports::PortBase *port, std::shared_ptr<riaps::MessageParams> params) {
         auto portName = port->GetPortName();
         if (portName == PORT_TIMER_CLOCK) {
            OnClock(port);
         }
      }
      
      void ComputationalComponentBase::DispatchInsideMessage(zmsg_t* zmsg, riaps::ports::PortBase* port) {
         //empty the header
      }
      
      bool ComputationalComponentBase::SendTx_modbusData(capnp::MallocMessageBuilder &messageBuilder,
                                                         logdata::messages::LogData::Builder &message) {
         return SendMessageOnPort(messageBuilder, PORT_PUB_TX_MODBUSDATA);
      }
      bool ComputationalComponentBase::SendModbusReqPort(capnp::MallocMessageBuilder &messageBuilder,
                                                         modbusuart::messages::CommandFormat::Builder &message) {
         return SendMessageOnPort(messageBuilder, PORT_REQ_MODBUSREQPORT);
      }
      
      bool ComputationalComponentBase::RecvModbusReqPort(modbusuart::messages::ResponseFormat::Reader &message) {
         auto port = GetRequestPortByName(PORT_REQ_MODBUSREQPORT);
         if (port == NULL) return false;
         
         capnp::FlatArrayMessageReader* messageReader;
         
         if (port->Recv(&messageReader)){
            message = messageReader->getRoot<modbusuart::messages::ResponseFormat>();
            return true;
         }
         return false;
      }
   }
}
